#!/usr/bin/env python
# -*- coding: utf-8 -*-
import sys
import json
import re

def parse_rpy_to_ast(script_content):
    root = {"ast_type": "root", "children": []}
    parent_stack = [(-1, root)]
    lines = script_content.splitlines()

    KNOWN_COMMANDS = ["scene", "show", "hide", "play", "stop", "jump", "return", "snapshot"]

    skipping_block = False
    skip_indent = -1

    for line in lines:
        stripped_line = line.strip()

        if skipping_block:
            if not stripped_line:
                continue
            current_indent = len(line) - len(line.lstrip(' '))
            if current_indent > skip_indent:
                continue
            else:
                skipping_block = False

        content = stripped_line.split('#', 1)[0].strip()

        if not content:
            continue

        indentation = len(line) - len(line.lstrip(' '))

        # MODIFIED: Skipper now ONLY looks for explicit 'python:' blocks.
        if content.endswith("python:"):
            skipping_block = True
            skip_indent = indentation
            continue

        while indentation <= parent_stack[-1][0]:
            parent_stack.pop()

        parent_node = parent_stack[-1][1]
        new_node = None
        is_block_starter = False
        
        keyword = content.split(' ', 1)[0]

        if keyword == "with":
            last_node = parent_node["children"][-1] if parent_node["children"] else None
            if last_node and last_node.get("type") in ["command", "dialogue"]:
                last_node["transition"] = content.split(' ', 1)[1] if ' ' in content else ""
            continue
        
        # NEW: Handle standard 'init' blocks as parsable nodes.
        if keyword == "init" and content.endswith(':'):
            priority_match = re.search(r'init\s+(-?\d+):', content)
            priority = int(priority_match.group(1)) if priority_match else 0
            new_node = {"type": "init_block", "priority": priority, "children": []}
            parent_node["children"].append(new_node)
            is_block_starter = True
        elif keyword in KNOWN_COMMANDS:
            args = content.split(' ', 1)[1] if ' ' in content else ""
            new_node = {"type": "command", "keyword": keyword, "args": args}
            parent_node["children"].append(new_node)
        elif content.startswith('label ') and content.endswith(':'):
            name = content[6:-1].strip()
            new_node = {"type": "label", "name": name, "children": []}
            parent_node["children"].append(new_node)
            is_block_starter = True
        elif content.startswith('menu') and content.endswith(':'):
            menu_name = content[4:-1].strip() if len(content) > 5 else None
            new_node = {"type": "menu", "children": []}
            if menu_name:
                new_node["name"] = menu_name
            parent_node["children"].append(new_node)
            is_block_starter = True
        elif content.startswith('"') and content.endswith('":'):
            text = content[1:-2]
            new_node = {"type": "choice", "text": text, "children": []}
            if parent_node.get("type") == "menu":
                parent_node["children"].append(new_node)
            is_block_starter = True
        elif content.startswith('if ') and content.endswith(':'):
            condition = content[3:-1].strip()
            new_node = {"type": "if_statement", "condition": condition, "children": []}
            parent_node["children"].append(new_node)
            is_block_starter = True
        elif content.startswith('elif ') and content.endswith(':'):
            condition = content[5:-1].strip()
            new_node = {"type": "elif_statement", "condition": condition, "children": []}
            last_sibling = parent_node["children"][-1] if parent_node["children"] else None
            if last_sibling and last_sibling.get("type") == "if_statement":
                if "elif_blocks" not in last_sibling:
                    last_sibling["elif_blocks"] = []
                last_sibling["elif_blocks"].append(new_node)
            is_block_starter = True
        elif content == 'else:':
            new_node = {"type": "else_statement", "children": []}
            last_sibling = parent_node["children"][-1] if parent_node["children"] else None
            if last_sibling and last_sibling.get("type") == "if_statement":
                last_sibling["else_block"] = new_node
            is_block_starter = True
        elif content.startswith('$'):
            # MODIFIED: Handle complex assignments by flagging them.
            if '(' in content and ')' in content:
                new_node = {"type": "python_expression", "expression": content}
            else:
                new_node = {"type": "variable_assignment", "expression": content}
            parent_node["children"].append(new_node)
        # MODIFIED: More robust regex for character names.
        elif (match := re.match(r'^(\w+)\s+"(.*)"$', content)):
            character, text = match.groups()
            new_node = {"type": "dialogue", "character": character, "text": text}
            parent_node["children"].append(new_node)
        elif content.startswith('"') and content.endswith('"'):
            text = content[1:-1]
            new_node = {"type": "dialogue", "character": "narrator", "text": text}
            parent_node["children"].append(new_node)
        else:
            if not content.startswith('define '): # We still ignore defines for now
                print(f"Warning: Unrecognized line format: {content}", file=sys.stderr)

        if is_block_starter and new_node:
            parent_stack.append((indentation, new_node))

    return root

def main():
    if len(sys.argv) != 2:
        print(f"Usage: python {sys.argv[0]} <path_to_rpy_file>", file=sys.stderr)
        sys.exit(1)
    input_file_path = sys.argv[1]
    try:
        with open(input_file_path, 'r', encoding='utf-8-sig') as f:
            script_content = f.read()
    except FileNotFoundError:
        print(f"Error: File not found at '{input_file_path}'", file=sys.stderr)
        sys.exit(1)

    ast = parse_rpy_to_ast(script_content)
    print(json.dumps(ast, indent=2))

if __name__ == "__main__":
    main()
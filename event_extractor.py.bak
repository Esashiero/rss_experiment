import json
import re
import sys
import os

def extract_events_from_screens(screens_rpy_path):
    """
    Parses a screens.rpy file to extract the master list of replayable events.

    This logic is based on the methodology from the Lessons-In-Love-Guide-Tool,
    which identifies events by finding the text buttons in the replay menu and
    their corresponding "Replay" actions.

    Args:
        screens_rpy_path (str): The full path to the screens.rpy file.

    Returns:
        dict: A dictionary of event details, with the event label as the key.
              Returns an empty dictionary if the file cannot be read.
    """
    if not os.path.exists(screens_rpy_path):
        print(f"Error: File not found at '{screens_rpy_path}'", file=sys.stderr)
        return {}

    try:
        with open(screens_rpy_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
    except Exception as e:
        print(f"Error reading file: {e}", file=sys.stderr)
        return {}

    events = {}
    current_event_group = None

    for i, line in enumerate(lines):
        stripped_line = line.strip()

        # A line like 'use game_menu(_("Ami Events"))' defines a new category.
        if "use game_menu(_(" in stripped_line and (" Events" in stripped_line or " SCENES" in stripped_line):
            try:
                current_event_group = stripped_line.split('"')[1].replace(" Events", "").replace(" SCENES", "").capitalize()
            except IndexError:
                # Handle cases where parsing might fail
                current_event_group = "Unknown"
            continue

        # If we are not inside a known event group, skip.
        if not current_event_group:
            continue
        
        # A 'textbutton' line represents a clickable event in the replay menu.
        if stripped_line.startswith("textbutton _(\""):
            # The user-visible name of the event.
            try:
                name = stripped_line.split('"')[1]
                # Clean the name, removing status markers and variables.
                name = name.replace("âœ“", "")
                name = re.sub(r"\(.*?\)", "", name) # Remove text in (parentheses)
                name = re.sub(r"\{.*?\}", "", name) # Remove text in {curly braces}
                name = name.strip()
            except IndexError:
                continue # Skip malformed line

            # The guide tool's logic assumes the actual event label is in an
            # 'action Replay("event_label")' line two lines below the textbutton.
            event_id = None
            if i + 2 < len(lines):
                action_line = lines[i+2].strip()
                if "action Replay" in action_line:
                    try:
                        event_id = action_line.split('"')[1]
                    except IndexError:
                        pass # Could not parse event_id

            # If we successfully found a clean name and an ID, add it to our master list.
            if event_id and name:
                events[event_id] = {
                    "id": event_id,
                    "name": name,
                    "group": current_event_group,
                }

    return events

def main():
    if len(sys.argv) != 2:
        print(f"Usage: python {sys.argv[0]} <path_to_screens.rpy>", file=sys.stderr)
        sys.exit(1)

    screens_path = sys.argv[1]
    
    print(f"--- Parsing Events from '{screens_path}' ---")
    master_event_list = extract_events_from_screens(screens_path)

    if not master_event_list:
        print("\nCould not find any events. Please check the file path and content.", file=sys.stderr)
    else:
        print(f"\n--- Successfully extracted {len(master_event_list)} events ---")
        print("Outputting as JSON:")
        # Print the extracted data as a nicely formatted JSON object.
        print(json.dumps(master_event_list, indent=2))

if __name__ == "__main__":
    main()